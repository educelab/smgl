#pragma once

/** @file */

#include <functional>
#include <map>
#include <memory>
#include <typeinfo>
#include <unordered_map>
#include <vector>

#include "smgl/Factory.hpp"
#include "smgl/Metadata.hpp"
#include "smgl/Ports.hpp"
#include "smgl/Singleton.hpp"
#include "smgl/Uuid.hpp"
#include "smgl/filesystem.hpp"

namespace smgl
{

/**
 * @brief Generic Node class
 *
 * Provides a base class for custom computation nodes. Typically, inputs and
 * outputs are defined by adding public InputPort and OutputPort members.
 * To customize Node behavior, assign or override the members Node::compute,
 * Node::serialize_, and Node::deserialize_.
 *
 * ```{.cpp}
 * using namespace smgl;
 *
 * class SumNode : public Node {
 * private:
 *     // Custom internal state
 *     int a_{0};
 *     int b_{0};
 *     int c_{a_ + b_};
 * public:
 *     // Define ports
 *     InputPort<int> a{&a_};
 *     InputPort<int> b{&b_};
 *     OutputPort<int> c{&c_};
 *
 *     SumNode() : Node() {
 *         // Must register ports
 *         registerInputPort("a", a);
 *         registerInputPort("b", b);
 *         registerOutputPort("c", c);
 *
 *         // Define compute behavior
 *         compute = [=]() { c_ = a_ + b_; };
 *     }
 *
 *     // Serialize state to Metadata
 *     Metadata serialize_(bool, const filesystem::path&) override {
 *         return {{"a", a_}, {"b", b_}, {"c", c_}};
 *     }
 *
 *     // Deserialize state from Metadata
 *     void deserialize_(const Metadata& m, const filesystem::path&) override {
 *         a_ = m["a"].get<int>();
 *         b_ = m["b"].get<int>();
 *         c_ = m["c"].get<int>();
 *     }
 * }
 * ```
 */
class Node : public UniquelyIdentifiable
{
public:
    /** Node update status */
    enum class Status {
        /** Does not need to be updated */
        Idle,
        /** Waiting on an upstream dependency to update */
        Waiting,
        /** Ready to be updated */
        Ready,
        /** Updating */
        Updating,
        /** Error updating */
        Error
    };

    /** Pointer type */
    using Pointer = std::shared_ptr<Node>;

    /** @brief Port registration information */
    struct Info {
        /** Constructor */
        Info(std::string n, const Uuid& u) : name{std::move(n)}, uuid{u} {}
        /** Registered name with parent Node */
        std::string name;
        /** Port UUID */
        Uuid uuid;
    };

    /**
     * @brief Update the Node
     *
     * Accepts any queued updates from registered InputPorts, computes a new
     * result as needed, and signals OutputPort connections with updated
     * results.
     */
    void update();

    /**
     * @brief Serialize the Node to Metadata, optionally caching to disk
     *
     * If `useCache` is true, this Node is allowed to create a subdirectory in
     * `cacheRoot` where it can write intermediate results. If `cacheRoot` is
     * empty, the current working directory will be used.
     *
     * Typically, users do not need to call this function directly and should
     * instead use Graph::Save.
     */
    Metadata serialize(bool useCache, const filesystem::path& cacheRoot);

    /**
     * @brief Deserialize the Node to Metadata
     *
     * Accepts a Metadata structure generated by serialize(). If that method was
     * called with `useCache == true`, then `cacheRoot` should point to the
     * same cache root directory.
     *
     * Typically, users do not need to call this function directly and should
     * instead use Graph::Load
     */
    void deserialize(const Metadata& meta, const filesystem::path& cacheRoot);

    /** @brief Get registered InputPort info */
    std::vector<Info> getInputPortsInfo() const;

    /** @brief Get registered OutputPort info */
    std::vector<Info> getOutputPortsInfo() const;

    /**
     * @brief Get a registered InputPort by Uuid
     * @throws std::out_of_range if Uuid not registered with Node
     */
    Input& getInputPort(const Uuid& uuid);
    /**
     * @brief Get a registered InputPort by registered name
     * @throws std::out_of_range if name not registered with Node
     */
    Input& getInputPort(const std::string& name);

    /**
     * @brief Get a registered OutputPort by Uuid
     * @throws std::out_of_range if Uuid not registered with Node
     */
    Output& getOutputPort(const Uuid& uuid);
    /**
     * @brief Get a registered OutputPort by registered name
     * @throws std::out_of_range if name not registered with Node
     */
    Output& getOutputPort(const std::string& name);

    /** @brief Get a list of active input connections */
    std::vector<Connection> getInputConnections() const;

    /** @brief Get the number of active input connections */
    size_t getNumberOfInputConnections() const;

    /** @brief Get a list of active output connections */
    std::vector<Connection> getOutputConnections() const;

    /** @brief Get the number of active output connections */
    size_t getNumberOfOutputConnections() const;

    /** @brief Get the current update status */
    Status status();

protected:
    /** Protected constructor can only be called by child class */
    Node();
    /** Protected constructor to set usesCacheDir value */
    explicit Node(bool usesCacheDir);
    /** Protected virtual destructor should override by child class */
    virtual ~Node() = default;

    /**
     * @brief Register an InputPort instance with this class
     *
     * @note Failing to register ports will cause errors in scheduling and
     * computation which are not always easy to identify.
     */
    template <typename T>
    void registerInputPort(const std::string& name, InputPort<T>& port);

    /**
     * @brief Register an OutputPort instance with this class
     *
     * @note Failing to register ports will cause errors in scheduling and
     * computation which are not always easy to identify.
     */
    template <typename T, typename... Args>
    void registerOutputPort(
        const std::string& name, OutputPort<T, Args...>& port);

    /**
     * @brief Function executed when Node's InputPorts have queued updates and
     * update() is called
     *
     * compute is of type std::function<void()> and can be assigned any
     * function which meets this signature. This includes function references
     * and lambda functions. By default, it is unassigned effectively a no-op.
     * It is generally preferable to assign this function in the child Node's
     * constructor.
     *
     * ```{.cpp}
     * // Free function
     * compute = &foo;
     *
     * // Member function (using smgl::WrapFunc for convenience)
     * #include <smgl/Utilities.hpp>
     * ...
     * compute = smgl::WrapFunc(&bar, &Bar::doWork);
     *
     * // Lambda function capturing local context
     * compute = [=]() { privateInt += 1; };
     * ```
     */
    std::function<void()> compute;

    /**
     * Function flag for whether this Node uses the cacheDir when serializing.
     * Replacing this function allows a child class to define whether or not
     * a cache directory is needed at runtime. The default implementation
     * returns false or the value passed to Node(bool).
     *
     * ```{.cpp}
     * struct Foo {
     *     std::unique_ptr<ComplexType> bar;
     *     Foo() {
     *         usesCacheDir = [&bar = bar](){ return bar != nullptr;};
     *     }
     * }
     * ```
     */
    std::function<bool()> usesCacheDir;

private:
    /**
     * @brief Serialize the Node's state to Metadata
     *
     * The public member function serialize() produces a Metadata object
     * containing all Node state information including Uuid, registered ports,
     * and custom state values. This method is called by serialize() and is
     * expected to provide any custom state information needed to faithfully
     * clone this Node instance.
     *
     * By default, this method produces an empty Metadata object. Child classes
     * of Node wishing to make use of the smgl serialization behavior should
     * override both serialize_() and deserialize_(). If the child
     * implementation needs to use the cache directory, it should either call
     * the Node(bool) constructor or redefine Node::usesCacheDir.
     *
     * Metadata supports direct serialization of many internal types and STL
     * and containers. For data types which are not supported, data may be
     * serialized directly to disk instead. If `useCache` is true, Node
     * implementations may write data to the directory passed by `cacheDir`. It
     * is good practice to serialize the name of any files written so that they
     * can later be easily identified by the deserialize_() process:
     *
     * ```{.cpp}
     * class MyNode : public Node {
     * private:
     *     Metadata serialize_(bool useCache, const path& cacheDir) override;
     * }
     *
     * Metadata MyNode::serialize_(bool useCache, const path& cacheDir) {
     *     Metadata m;
     *     if (useCache) {
     *         std::ofstream fs(cacheDir / "value.txt");
     *         fs << value_;
     *         fs.close();
     *         m["cacheFile"] = "value.txt";
     *     }
     *     return m;
     * }
     * ```
     */
    virtual Metadata serialize_(
        bool useCache, const filesystem::path& cacheDir);

    // clang-format off
    /**
     * @brief Deserialize the Node's state from Metadata
     *
     * This method is called by deserialize() and is expected to load any custom
     * state information needed to faithfully clone a previous Node instance.
     * The Metadata argument `data` is one produced by the serialize_(). If that
     * method was called with `useCache == true`, then `cacheDir` should point
     * to the same node cache directory.
     *
     * By default, this method does nothing. Child classes of Node wishing to
     * make use of the smgl serialization behavior should override both
     * serialize_() and deserialize_(). If the child implementation needs to
     * use the cache directory, it should either call the Node(bool) constructor
     * or redefine Node::usesCacheDir.
     *
     * Metadata supports direct deserialization of many internal types and STL
     * containers using the `get` template method. For data types which are not
     * supported, data may be loaded from disk instead. It is good practice to
     * serialize the name of any files that need to be loaded during
     * deserialization when overriding serialize_().
     *
     * ```{.cpp}
     * class MyNode : public Node {
     * private:
     *     void deserialize_(const Metadata& data, const path& cacheDir) override;
     * }
     *
     * void MyNode::deserialize_(const Metadata& data, const path& cacheDir) {
     *     if(data.contains("cacheFile") {
     *         auto file = data["cacheFile"].get<std::string>();
     *         std::ifstream fs(cacheDir / file);
     *         std::getline(fs, value_);
     *         fs.close();
     *     }
     * }
     * ```
     */
    // clang-format on
    virtual void deserialize_(
        const Metadata& data, const filesystem::path& cacheDir);

    /**
     * Receive all queued updates on registered InputPorts. Returns true if any
     * port successfully updates.
     */
    bool update_input_ports_();

    /** Notify output ports of this Node's update status */
    void notify_output_ports_(Port::Status s);

    /** Send queued update on all output ports */
    bool update_output_ports_();

    /**
     * Convenience method for loading existing port information and updating
     * port registrations
     */
    template <class PortType>
    static void LoadAndRegisterPort(
        const std::string& name,
        const Metadata& data,
        std::unordered_map<Uuid, PortType*>& byUuid,
        std::map<std::string, PortType*>& byName);

    /** Stores registered inputs by Uuid */
    std::unordered_map<Uuid, Input*> inputs_by_uuid_;
    /** Stores registered inputs by registered name */
    std::map<std::string, Input*> inputs_by_name_;
    /** Stores registered outputs by Uuid */
    std::unordered_map<Uuid, Output*> outputs_by_uuid_;
    /** Stores registered outputs by registered name */
    std::map<std::string, Output*> outputs_by_name_;
    /** Current Node status */
    Status status_{Status::Idle};
};

namespace detail
{
/**
 * Node Factory Singleton Type
 *
 * @warning Should not be used directly. Use the factory interaction functions
 * provided in the top-level namespace: RegisterNode(), DeregisterNode(),
 * CreateNode(), NodeName()
 */
using NodeFactoryType =
    SingletonHolder<Factory<Node, std::string, Node::Pointer>>;
}  // namespace detail

/** Thrown by NodeFactoryType when attempting to access an unregistered type */
using unknown_identifier =
    detail::NodeFactoryType::InstanceType::unknown_identifier;

/**
 * @brief Register Node types for serialization/deserialization using an
 * automatically generated name
 *
 * This function uses the demangled, compiled object name (e.g. `smgl::MyNode`)
 * as the registered Node name. Note that this can result in non-human readable
 * node names when using complex templated type names.
 *
 * Node registration is global and only needs to be performed once during
 * execution of a program.
 *
 * @returns Whether or not registration was successful for all provided types
 */
template <class T, class... Ts>
bool RegisterNode();

/**
 * @brief Register a Node type for serialization/deserialization using a
 * custom name
 *
 * Node registration is global and only needs to be performed once during
 * execution of a program.
 */
template <class T>
bool RegisterNode(const std::string& name);

/**
 * @brief Deregister a Node type
 *
 * Uses RTTI to lookup existing registration information.
 *
 * Because Node registration is global, this typically only needs to be called
 * when testing or debugging custom Nodes.
 *
 * @returns Whether or not de-registration was successful for all provided types
 */
template <class T, class... Ts>
bool DeregisterNode();

/**
 * @brief Deregister a Node type by Name
 *
 * Because Node registration is global, this typically only needs to be called
 * when testing or debugging custom Nodes.
 */
bool DeregisterNode(const std::string& name);

/**
 * Create a Node using it's registered name
 */
Node::Pointer CreateNode(const std::string& name);

/**
 * Get a Node's registered name
 *
 * @throws smgl::unknown_identifier if the type pointed to by node has not been
 * registered
 */
template <class T>
std::string NodeName();

/** @copydoc NodeName() */
std::string NodeName(const Node::Pointer& node);

/** @copydoc NodeName() */
std::string NodeName(const Node* node);

/** Check whether a name has been registered for a Node type */
bool IsRegistered(const std::string& name);

/** Check whether a Node's type has been registered */
bool IsRegistered(const Node::Pointer& node);

/** Check whether a Node's type has been registered */
bool IsRegistered(const Node* node);

}  // namespace smgl

#include "smgl/NodeImpl.hpp"